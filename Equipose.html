<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>CardioSynthesizer V5.5: Reanalysis Engine</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&family=Inter:wght@300;400;500;600;700&family=Merriweather:wght@300;400;700&display=swap" rel="stylesheet">
  <style>
    /* --- Theme: "Hemo-Dynamic V5.5" --- */
    :root {
      --bg-dark: #050505;
      --bg-panel: #0f1014;
      --bg-input: #181a20;
      --accent: #ef4444;        /* Bleeding (Red) */
      --benefit: #10b981;       /* Ischemia (Green) */
      --warn: #f59e0b;
      --text-main: #e5e7eb;
      --text-muted: #9ca3af;
      --border: #27272a;
      --font-sans: 'Inter', sans-serif;
      --font-serif: 'Merriweather', serif;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; overflow: hidden; }
    body { background: var(--bg-dark); color: var(--text-main); font-family: var(--font-sans); display: flex; }
    
    .app-shell { display: grid; grid-template-columns: 380px 1fr 340px; width: 100%; height: 100%; }
    
    .sidebar-left, .sidebar-right { background: var(--bg-panel); display: flex; flex-direction: column; overflow: hidden; z-index: 10; border-color: var(--border); border-style: solid; }
    .sidebar-left { border-width: 0 1px 0 0; }
    .sidebar-right { border-width: 0 0 0 1px; }
    .sidebar-content { padding: 20px; overflow-y: auto; flex: 1; display: flex; flex-direction: column; gap: 20px; }
    
    .main-stage { padding: 0; display: flex; flex-direction: column; overflow-y: auto; position: relative; scroll-behavior: smooth; background: radial-gradient(circle at 50% 20%, #16181f 0%, #050505 60%); }

    /* Titles */
    h1 { font-size: 1.1rem; font-weight: 700; color: #fff; letter-spacing: -0.02em; }
    h2 { font-size: 0.75rem; font-weight: 700; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 8px; }

    /* Controls */
    .control-group { display: flex; flex-direction: column; gap: 8px; }
    label { display: flex; justify-content: space-between; align-items: center; font-size: 0.75rem; color: var(--text-muted); font-weight: 600; }
    .val-display { color: var(--benefit); font-family: 'JetBrains Mono', monospace; background: rgba(16, 185, 129, 0.1); padding: 2px 6px; border-radius: 4px; font-size: 0.75rem; }
    
    .toggle-group { display: flex; background: var(--bg-input); border: 1px solid var(--border); border-radius: 6px; padding: 3px; }
    .toggle-btn { flex: 1; padding: 8px; text-align: center; font-size: 0.75rem; font-weight: 600; color: var(--text-muted); border-radius: 4px; cursor: pointer; transition: all 0.2s; }
    .toggle-btn.active { background: #2d2f36; color: #fff; box-shadow: 0 1px 4px rgba(0,0,0,0.4); }
    
    /* Anatomical Checks */
    .check-grid { display: grid; grid-template-columns: 1fr; gap: 8px; background: var(--bg-input); padding: 12px; border-radius: 8px; border: 1px solid var(--border); }
    .check-item { display: flex; align-items: center; gap: 10px; font-size: 0.8rem; color: var(--text-muted); cursor: pointer; transition: color 0.2s; }
    .check-item:hover { color: #fff; }
    .check-item input { accent-color: var(--benefit); width: 14px; height: 14px; }
    
    /* Assumptions Panel */
    .assumptions-panel { background: rgba(245, 158, 11, 0.05); border: 1px solid rgba(245, 158, 11, 0.2); border-radius: 8px; padding: 12px; margin-top: 5px; }
    .assumptions-panel h3 { color: var(--warn); font-size: 0.7rem; font-weight: 700; text-transform: uppercase; margin-bottom: 10px; display:flex; align-items:center; gap:6px; }
    
    /* Inputs */
    input[type="range"] { -webkit-appearance: none; width: 100%; height: 4px; background: #333; border-radius: 2px; outline: none; margin: 8px 0; }
    input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 14px; height: 14px; background: #d1d5db; border-radius: 50%; cursor: pointer; border: 2px solid var(--bg-panel); transition: transform 0.1s; }
    input[type="range"]::-webkit-slider-thumb:hover { transform: scale(1.2); background: #fff; }
    
    .slider-row { display: flex; flex-direction: column; gap: 2px; margin-bottom: 8px; }
    .slider-lbl { font-size: 0.65rem; color: var(--text-muted); display:flex; justify-content:space-between; }
    
    .info-icon { cursor: help; border-bottom: 1px dotted #777; }

    /* Trial List */
    .trial-list { display: flex; flex-direction: column; gap: 1px; max-height: 150px; overflow-y: auto; padding: 6px; background: var(--bg-input); border-radius: 8px; border: 1px solid var(--border); }
    .trial-item { display: flex; align-items: center; font-size: 0.7rem; color: var(--text-muted); padding: 4px; border-radius: 4px; }
    .trial-item:hover { background: rgba(255,255,255,0.05); color: #fff; }
    .trial-item input { margin-right: 8px; accent-color: var(--benefit); }

    /* Buttons */
    .run-btn { background: var(--text-main); color: var(--bg-dark); border: none; padding: 12px; border-radius: 6px; font-weight: 700; cursor: pointer; margin-top: 10px; display: flex; align-items: center; justify-content: center; gap: 10px; font-size: 0.85rem; transition: all 0.2s; }
    .run-btn:hover { background: #fff; transform: translateY(-1px); }
    .run-btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }

    .export-btn { background: #27272a; color: #fff; border: 1px solid #3f3f46; padding: 8px; border-radius: 4px; font-size: 0.7rem; cursor: pointer; margin-top: 10px; width: 100%; transition: all 0.2s; }
    .export-btn:hover { background: #3f3f46; }
    
    /* Viz Containers */
    .viz-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 30px; padding: 0 40px; max-width: 1200px; margin: 0 auto; width: 100%; }
    .full-width { grid-column: 1 / -1; }
    .viz-container { background: var(--bg-input); border: 1px solid var(--border); border-radius: 10px; display: flex; flex-direction: column; min-height: 280px; overflow: hidden; position: relative; }
    .viz-header { padding: 10px 15px; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; }
    .viz-title { font-size: 0.7rem; font-weight: 700; text-transform: uppercase; color: var(--text-muted); }
    canvas { width: 100%; height: 100%; display: block; flex: 1; }

    /* Metrics Right */
    .metric-card { background: var(--bg-input); border-radius: 8px; padding: 15px; border-left: 3px solid var(--border); display: flex; flex-direction: column; gap: 4px; }
    .metric-card.pos { border-color: var(--benefit); }
    .metric-card.neg { border-color: var(--accent); }
    .m-val { font-size: 1.4rem; font-family: 'JetBrains Mono', monospace; font-weight: 700; color: #fff; }
    .m-sub { font-size: 0.7rem; color: #666; }

    /* Narrative */
    .narrative-container { padding: 40px 40px 20px 40px; max-width: 1200px; margin: 0 auto; width: 100%; }
    .narrative-headline { font-family: var(--font-serif); font-size: 1.8rem; font-weight: 700; color: #fff; margin-bottom: 5px; }
    .narrative-sub { font-family: var(--font-sans); font-size: 0.9rem; color: var(--text-muted); display:flex; align-items:center; gap: 10px; }
    
    .badge { padding: 4px 8px; border-radius: 4px; font-size: 0.7rem; font-weight: 700; text-transform: uppercase; }
    .badge-gray { background: #333; color: #ccc; }

    /* Report */
    .report-box { margin: 20px 40px; background: var(--bg-panel); border: 1px solid var(--border); padding: 30px; border-radius: 8px; font-family: 'JetBrains Mono', monospace; font-size: 0.8rem; color: #d1d5db; line-height: 1.6; }

    .loader { width: 14px; height: 14px; border: 2px solid rgba(0,0,0,0.2); border-top-color: #000; border-radius: 50%; animation: spin 0.8s linear infinite; display: none; }
    .run-btn.processing .loader { display: block; }
    @keyframes spin { to { transform: rotate(360deg); } }
    
    @media (max-width: 1200px) { .app-shell { grid-template-columns: 340px 1fr; } .sidebar-right { display: none; } }
  </style>
</head>
<body>

<div class="app-shell">
  <!-- LEFT: CONFIGURATION -->
  <aside class="sidebar-left">
    <div class="sidebar-content">
      <div>
        <h1>CardioSynth <span style="color:var(--benefit)">v5.5</span></h1>
        <p style="font-size: 0.75rem; color: var(--text-muted);">Reanalysis & Simulation Engine</p>
      </div>

      <!-- CONTEXT -->
      <div class="control-group">
        <label>Strategy & Context</label>
        <div class="toggle-group">
          <div id="btnShort" class="toggle-btn">Short DAPT</div>
          <div id="btnExt" class="toggle-btn active">Extended (>12m)</div>
        </div>
        <div class="toggle-group" style="margin-top:4px;">
          <div id="btnACS" class="toggle-btn active">ACS</div>
          <div id="btnCCS" class="toggle-btn">CCS</div>
        </div>
      </div>

      <!-- ANATOMY -->
      <div class="control-group">
        <label>Anatomical Complexity <span id="lblComplex" class="val-display">Score: 0</span></label>
        <div class="check-grid" id="anatomyGrid">
          <label class="check-item"><input type="checkbox" value="30"> Left Main</label>
          <label class="check-item"><input type="checkbox" value="20"> Bifurcation</label>
          <label class="check-item"><input type="checkbox" value="20"> Total Stent > 60mm</label>
          <label class="check-item"><input type="checkbox" value="50"> Prior Stent Thrombosis</label>
          <label class="check-item"><input type="checkbox" value="20"> Multivessel Disease</label>
        </div>
      </div>

      <!-- BLEEDING -->
      <div class="control-group">
        <label>Bleeding Risk (PRECISE-DAPT) <span id="lblScore" class="val-display">15</span></label>
        <input type="range" id="scoreInput" min="0" max="60" value="15" step="1">
      </div>

      <!-- STATISTICAL ASSUMPTIONS -->
      <div class="assumptions-panel">
        <h3><span>âš¡</span> Reanalysis Parameters</h3>
        
        <div class="slider-row">
          <div class="slider-lbl">
            <span>Complexity Beta (&beta;) <span class="info-icon" title="Effect modifier: Each 10-point increase in complexity score changes the log-OR by (Beta/10). Example: Beta=0.5, Complexity=70 â†’ logOR multiplied by 1.10. Set to 0 for no interaction.">â“˜</span></span>
            <span id="lblBeta">0.5</span>
          </div>
          <input type="range" id="betaInput" min="0.0" max="2.0" step="0.1" value="0.5">
          <div style="font-size:0.6rem; color:#666;">Interaction strength (0 = No Interaction).</div>
        </div>

        <div class="slider-row">
          <div class="slider-lbl">
             <span>Correlation (&rho;) <span class="info-icon" title="Correlation between ischemia and bleeding outcomes. Negative values indicate competing risks.">â“˜</span></span>
             <span id="lblRho">0.2</span>
          </div>
          <input type="range" id="rhoInput" min="-1.0" max="1.0" step="0.1" value="0.2">
          <div style="font-size:0.6rem; color:#666;">Ischemia/Bleeding dependency.</div>
        </div>
        
        <label style="display:flex; align-items:center; gap:8px; font-size:0.7rem; margin-top:10px; color:var(--text-muted); cursor:pointer;">
          <input type="checkbox" id="autoRun" checked style="accent-color:var(--benefit);">
          <span>Auto-run on parameter changes</span>
        </label>
      </div>

      <!-- SENSITIVITY -->
      <div class="control-group" style="flex:1;">
        <label>Trial Inclusion (Sensitivity)</label>
        <div class="trial-list" id="trialList"></div>
      </div>

      <button id="runBtn" class="run-btn">
        <div class="loader"></div>
        <span>Run Reanalysis</span>
      </button>

      <button id="exportBtn" class="export-btn">
         ðŸ“¥ Export JSON
      </button>
    </div>
  </aside>

  <!-- CENTER: VISUALIZATION -->
  <main class="main-stage">
    <div class="narrative-container">
      <div class="narrative-sub">
        <span class="badge badge-gray">Reanalysis Output</span>
        <span id="lblDate"></span>
      </div>
      <div id="dynamicHeadline" class="narrative-headline">Ready to Synthesize</div>
      <div id="dynamicSubhead" class="narrative-sub">Adjust parameters to generate Net Clinical Benefit probability.</div>
    </div>

    <!-- 1. TIPPING POINT -->
    <div class="viz-grid full-width">
      <div class="viz-container full-width" style="height: 240px;">
        <div class="viz-header">
          <span class="viz-title">Tipping Point Analysis</span>
          <span class="viz-title" style="color:var(--text-main)">Net Benefit vs. Harm Weight</span>
        </div>
        <canvas id="thresholdCanvas"></canvas>
      </div>
    </div>

    <!-- 2. SCATTER & TIME -->
    <div class="viz-grid">
      <div class="viz-container">
        <div class="viz-header">
           <span class="viz-title">Risk-Benefit Plane (Monte Carlo)</span>
        </div>
        <canvas id="scatterCanvas"></canvas>
      </div>
      
      <div class="viz-container">
        <div class="viz-header">
           <span class="viz-title">Digital Twin: Time Horizon</span>
        </div>
        <canvas id="timeCanvas"></canvas>
      </div>
    </div>

    <!-- 3. FOREST & HISTOGRAM -->
    <div class="viz-grid">
      <div class="viz-container">
        <div class="viz-header">
           <span class="viz-title">Meta-Analysis (Ischemia)</span>
        </div>
        <canvas id="forestCanvas"></canvas>
      </div>
      
      <div class="viz-container">
        <div class="viz-header">
           <span class="viz-title">NCB Distribution (Harm Weight=1.0)</span>
        </div>
        <canvas id="histCanvas"></canvas>
      </div>
    </div>

    <!-- REPORT -->
    <div class="report-box">
      <div style="margin-bottom:10px; color:#fff; font-weight:700;">// GENERATED METHODOLOGY REPORT</div>
      <div id="reportContent">Waiting for simulation...</div>
    </div>
  </main>

  <!-- RIGHT: METRICS -->
  <aside class="sidebar-right">
    <div class="sidebar-content">
      <h2>Simulation Metrics</h2>

      <div class="metric-card" id="cardNCB">
        <div class="m-title">Net Clinical Benefit</div>
        <div class="m-val" id="valNCB">--</div>
        <div class="m-sub">Weighted Absolute Risk Difference</div>
      </div>

      <div class="metric-card">
        <div class="m-title">Probability of Benefit</div>
        <div class="m-val" id="valProb" style="color: var(--benefit);">--</div>
        <div class="m-sub">Confidence Level (N=40k)</div>
      </div>
      
      <div style="border-top:1px solid var(--border); padding-top:20px;">
        <h2>Impact Analysis</h2>
        <div class="metric-card pos" style="margin-bottom:10px; border-color:var(--benefit);">
           <div class="m-title" style="color:var(--benefit)">NNT (Ischemia)</div>
           <div class="m-val" id="valNNT">--</div>
        </div>
        <div class="metric-card neg" style="border-color:var(--accent);">
           <div class="m-title" style="color:var(--accent)">NNH (Bleeding)</div>
           <div class="m-val" id="valNNH">--</div>
        </div>
      </div>

      <div class="metric-card" style="margin-top:20px; background:transparent; border:1px dashed #333;">
         <div class="m-title">Tipping Point</div>
         <div class="m-val" id="valTip">--</div>
         <div class="m-sub">Harm Weight Threshold</div>
      </div>

      <!-- Hidden Inputs for Calculation -->
      <input type="hidden" id="baseB" value="4.0">
      <input type="hidden" id="baseH" value="1.2">
    </div>
  </aside>
</div>

<!-- WORKER: THE STATISTICAL ENGINE -->
<script id="worker-code" type="javascript/worker">
  self.onmessage = function(e) {
    const { 
      trials, baseB, baseH, nSims, 
      complexityScore, strategy, indication, excludedIds,
      rho, betaInput 
    } = e.data;
    
    // 1. Filter
    const activeTrials = trials.filter(t => !excludedIds.includes(t.id));
    if(activeTrials.length === 0) { self.postMessage({type:'error'}); return; }

    // 2. Modifiers
    // TRANSPARENCY FIX: No hidden scalars. 
    // Effect Modification = (ScoreCentered / 100) * Beta
    // Score 0-100. Centered at 50. Range -0.5 to +0.5.
    const complexMod = ((complexityScore - 50) / 100) * betaInput;

    // 3. Process Trials
    const processedTrials = activeTrials.map(t => {
      let bLog = t.logOR_benefit;
      
      // Apply Interaction if Strategy is Extended
      if (strategy === 'extended') {
         // Direct application of Beta. No hidden multipliers.
         // Example: If ComplexMod = 0.25 (High complexity), and logOR is negative (benefit),
         // we multiply by (1 + 0.25) to increase benefit magnitude.
         bLog = bLog * (1 + complexMod); 
         
         // Note: CCS penalty removed to maintain strict transparency.
      }
      
      let hLog = t.logOR_harm; 
      
      // Flip logic for Short Strategy
      if (strategy === 'short') {
        bLog = -bLog; // Ben -> Harm
        hLog = -hLog; // Harm -> Ben
      }
      return { ...t, logOR_benefit: bLog, logOR_harm: hLog };
    });

    // 4. DerSimonian-Laird Random Effects Meta-Analysis
    const reB = runREML(processedTrials, 'logOR_benefit', 'SE_benefit');
    const reH = runREML(processedTrials, 'logOR_harm', 'SE_harm');
    
    // Egger's Test for Small Study Effects (Publication Bias)
    const egger = eggerTest(processedTrials, 'logOR_benefit', 'SE_benefit');

    // 5. Monte Carlo Core
    const plotPoints = [];
    const ncbValues = []; 
    let sumB = 0, sumH = 0;
    const sdB = Math.sqrt(reB.se_pool**2 + reB.tau2); 
    const sdH = Math.sqrt(reH.se_pool**2 + reH.tau2); 
    const sqrtRho = Math.sqrt(1 - rho*rho);

    for(let i=0; i<nSims; i++) {
      let u=0, v=0;
      while(u===0) u=Math.random(); while(v===0) v=Math.random();
      const z1 = Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
      while(u===0) u=Math.random(); while(v===0) v=Math.random();
      const z2 = Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);

      const lB = reB.mu + sdB * z1;
      const lH = reH.mu + sdH * (rho * z1 + sqrtRho * z2);

      const deltaIsch = probFromLogOR(baseB, lB);
      const deltaBleed = probFromLogOR(baseH, lH); 
      
      sumB += deltaIsch; sumH += deltaBleed;

      const ncb = deltaIsch + deltaBleed;
      ncbValues.push(ncb);

      if(i % 40 === 0 && plotPoints.length < 1000) {
        plotPoints.push({ x: deltaBleed*100, y: deltaIsch*100 });
      }
    }

    const meanB = sumB / nSims;
    const meanH = sumH / nSims;
    const positiveCount = plotPoints.filter(p => (p.y + p.x) > 0).length * (nSims/1000); 

    // Calculate CI for NCB
    ncbValues.sort((a,b)=>a-b);
    const ncb_p025 = ncbValues[Math.floor(nSims * 0.025)];
    const ncb_p975 = ncbValues[Math.floor(nSims * 0.975)];

    // 6. Threshold Sensitivity
    const thresholds = [];
    let tippingPoint = null;
    let prevNCB = null;

    for(let w = 0.5; w <= 5.0; w += 0.1) {
        const ncb = meanB + (meanH * w);
        thresholds.push({ w: w, val: ncb });
        if (prevNCB !== null && ((prevNCB > 0 && ncb < 0) || (prevNCB < 0 && ncb > 0))) {
             tippingPoint = w - 0.05; 
        }
        prevNCB = ncb;
    }

    // 7. Time Horizon Models
    const timeData = [];
    for(let m=0; m<=36; m++) {
        // Models: Ischemia = Exponential Saturation. Bleeding = Linear Accumulation.
        const tIsch = (1 - Math.exp(-m/12));
        const tBleed = (m/12);
        
        const bi = baseB * 100 * (tIsch / (1-Math.exp(-3)));
        const bb = baseH * 100 * (tBleed / 3);
        const ti = (baseB - meanB) * 100 * (tIsch / (1-Math.exp(-3)));
        const tb = (baseH - meanH) * 100 * (tBleed / 3);
        timeData.push({ m, bi, bb, ti, tb });
    }

    // 8. Histogram Construction
    const histData = buildHistogram(ncbValues, 40);

    self.postMessage({ 
      type: 'complete', 
      data: { reB, reH, plotPoints, meanB, meanH, positiveCount, timeData, strategy, thresholds, tippingPoint, rho, betaInput, histData, ncb_p025, ncb_p975, egger } 
    });
  };

  // Risk Difference Calculation
  function probFromLogOR(base, logOR) {
    const odds = base / (1 - base);
    const newOdds = odds * Math.exp(logOR);
    const newProb = newOdds / (1 + newOdds);
    return newProb - base;
  }

  // Egger's Test (Regression of effect on precision)
  function eggerTest(data, kEff, kSe) {
    if(data.length < 3) return null;
    const effects = data.map(d => d[kEff]);
    const precision = data.map(d => 1/d[kSe]);
    const n = effects.length;
    
    const meanP = precision.reduce((a,b)=>a+b)/n;
    const meanE = effects.reduce((a,b)=>a+b)/n;
    
    let num=0, den=0;
    for(let i=0; i<n; i++) {
        num += (precision[i] - meanP) * (effects[i] - meanE);
        den += (precision[i] - meanP)**2;
    }
    const slope = num / den;
    const intercept = meanE - slope * meanP;
    
    // T-stat for intercept
    const residuals = effects.map((e, i) => e - (intercept + slope * precision[i]));
    const ssr = residuals.reduce((a, b) => a + b*b, 0);
    const syx = Math.sqrt(ssr / (n - 2));
    const ssx = den; 
    // SE of intercept
    const se_int = syx * Math.sqrt(1/n + (meanP*meanP)/ssx);
    const t = intercept / se_int;
    const pval = (Math.abs(t) > 2.0) ? "<0.05" : ">0.05"; // Simplified approx
    
    return { intercept, pval };
  }

  // DerSimonian-Laird Estimator
  function runREML(data, kEff, kSe) {
    const y = data.map(d => d[kEff]);
    const v = data.map(d => d[kSe]**2);
    
    // Fixed-effects
    const wFE = v.map(x => 1/x);
    const swFE = wFE.reduce((a,b) => a+b, 0);
    const muFE = wFE.reduce((a,b,j) => a + b*y[j], 0) / swFE;
    
    // Q statistic
    const Q = wFE.reduce((sum, w, j) => sum + w * (y[j] - muFE)**2, 0);
    const df = Math.max(1, data.length - 1);
    const C = swFE - wFE.reduce((sum, w) => sum + w**2, 0) / swFE;
    
    // Tau^2 & I^2
    const tau2 = Math.max(0, (Q - df) / C);
    const I2 = Math.max(0, (Q - df) / Q * 100);

    // Random-effects
    const wRE = v.map(x => 1/(x + tau2));
    const swRE = wRE.reduce((a,b) => a+b, 0);
    const muRE = wRE.reduce((a,b,j) => a + b*y[j], 0) / swRE;
    
    // Prediction Interval (95%)
    const se_pool = Math.sqrt(1/swRE);
    const se_pred = Math.sqrt(se_pool**2 + tau2);
    const pred_lo = muRE - 1.96 * se_pred;
    const pred_hi = muRE + 1.96 * se_pred;

    return {
      mu: muRE,
      se_pool: se_pool,
      tau2: tau2,
      I2: I2,
      pred_lo, pred_hi,
      forest: data.map(d => ({ 
          id: d.id, 
          val: d[kEff], 
          lo: d[kEff] - 1.96*d[kSe], 
          hi: d[kEff] + 1.96*d[kSe] 
      }))
    };
  }

  function buildHistogram(arr, bins) {
    if(arr.length === 0) return [];
    const p05 = arr[Math.floor(arr.length*0.05)];
    const p95 = arr[Math.floor(arr.length*0.95)];
    const min = p05, max = p95;
    const range = max - min;
    const step = range / bins;
    const res = [];
    let current = min;
    let idx = 0;
    while(idx < arr.length && arr[idx] < min) idx++;
    for(let i=0; i<bins; i++) {
      let count = 0;
      const next = current + step;
      while(idx < arr.length && arr[idx] < next) { count++; idx++; }
      res.push({ x: (current + step/2)*100, y: count });
      current = next;
    }
    return res;
  }
</script>

<!-- APP LOGIC -->
<script>
  // TRIAL DATABASE
  const TRIALS = [
    { id: "PEGASUS",         logOR_benefit: -0.16, SE_benefit: 0.06, logOR_harm: 0.84, SE_harm: 0.12 },
    { id: "DAPT Study",      logOR_benefit: -0.21, SE_benefit: 0.05, logOR_harm: 0.65, SE_harm: 0.09 },
    { id: "PRODIGY",         logOR_benefit: -0.09, SE_benefit: 0.15, logOR_harm: 0.70, SE_harm: 0.20 },
    { id: "ITALIC",          logOR_benefit: 0.05,  SE_benefit: 0.20, logOR_harm: 0.50, SE_harm: 0.30 },
    { id: "SECURITY",        logOR_benefit: 0.02,  SE_benefit: 0.19, logOR_harm: 0.20, SE_harm: 0.35 },
    { id: "TWILIGHT",        logOR_benefit: -0.01, SE_benefit: 0.14, logOR_harm: 0.58, SE_harm: 0.15 }, 
    { id: "GLOBAL LEADERS",  logOR_benefit: -0.13, SE_benefit: 0.08, logOR_harm: 0.00, SE_harm: 0.10 },
    { id: "TICO",            logOR_benefit: 0.05,  SE_benefit: 0.18, logOR_harm: 0.58, SE_harm: 0.19 }, 
    { id: "STOPDAPT-2",      logOR_benefit: 0.23,  SE_benefit: 0.22, logOR_harm: 1.35, SE_harm: 0.25 },
    { id: "SMART-CHOICE",    logOR_benefit: 0.00,  SE_benefit: 0.16, logOR_harm: 0.45, SE_harm: 0.21 },
    { id: "MASTER-DAPT",     logOR_benefit: 0.02,  SE_benefit: 0.12, logOR_harm: 0.45, SE_harm: 0.15 } 
  ];

  const blob = new Blob([document.getElementById('worker-code').textContent], {type: "text/javascript"});
  const worker = new Worker(window.URL.createObjectURL(blob));
  
  let state = {
    strategy: 'extended',
    indication: 'acs',
    complexity: 0,
    excludedIds: []
  };

  // Global store for export
  let lastResults = null;

  // Error Handling
  worker.onerror = function(err) {
      console.error(err);
      alert("Simulation Worker Error. See console.");
      document.getElementById('runBtn').classList.remove('processing');
      document.getElementById('runBtn').disabled = false;
  };

  worker.onmessage = e => {
    if (e.data.type === 'error') {
        alert("Simulation Error");
        return;
    }
    if (e.data.type === 'complete') {
      const d = e.data.data;
      lastResults = d; // Store for export
      drawScatter(d);
      drawTimeHorizon(d.timeData);
      drawThreshold(d.thresholds, d.tippingPoint);
      drawForest(d.reB, d.egger); 
      drawHist(d.histData); 
      updateMetrics(d);
      generateMethodReport(d);
      document.getElementById('runBtn').classList.remove('processing');
      document.getElementById('runBtn').disabled = false;
    }
  };

  // Debounce Utility
  let debounceTimer;
  function debounce(func, delay) {
      clearTimeout(debounceTimer);
      debounceTimer = setTimeout(func, delay);
  }

  // --- INIT ---
  window.onload = () => {
    document.getElementById('lblDate').textContent = new Date().toISOString().slice(0,10);
    initTrialList();
    initEventListeners();
    calcComplexity(); 
    updateBleed();
  };

  // --- EVENT LISTENERS ---
  function initEventListeners() {
    document.getElementById('btnShort').addEventListener('click', () => setStrategy('short'));
    document.getElementById('btnExt').addEventListener('click', () => setStrategy('extended'));
    document.getElementById('btnACS').addEventListener('click', () => setIndication('acs'));
    document.getElementById('btnCCS').addEventListener('click', () => setIndication('ccs'));
    
    document.getElementById('runBtn').addEventListener('click', startSimulation);
    document.getElementById('exportBtn').addEventListener('click', exportResults);

    document.querySelectorAll('#anatomyGrid input').forEach(input => {
      input.addEventListener('change', calcComplexity);
    });
    
    // Auto-Run Check
    document.getElementById('scoreInput').addEventListener('input', () => autoRunOrDebounce(updateBleed));
    document.getElementById('betaInput').addEventListener('input', () => autoRunOrDebounce(updateAssumptions));
    document.getElementById('rhoInput').addEventListener('input', () => autoRunOrDebounce(updateAssumptions));
  }

  function autoRunOrDebounce(fn) {
     if(document.getElementById('autoRun').checked) {
        debounce(fn, 300);
     } else {
        // Just update UI values without running sim
        fn(true); 
     }
  }

  // --- ACTIONS ---
  function setStrategy(s) {
    state.strategy = s;
    document.getElementById('btnShort').className = s === 'short' ? 'toggle-btn active' : 'toggle-btn';
    document.getElementById('btnExt').className = s === 'extended' ? 'toggle-btn active' : 'toggle-btn';
    if(document.getElementById('autoRun').checked) startSimulation();
  }

  function setIndication(ind) {
    state.indication = ind;
    document.getElementById('btnACS').className = ind === 'acs' ? 'toggle-btn active' : 'toggle-btn';
    document.getElementById('btnCCS').className = ind === 'ccs' ? 'toggle-btn active' : 'toggle-btn';
    if(document.getElementById('autoRun').checked) startSimulation();
  }

  function calcComplexity(skipSim) {
    const checks = document.querySelectorAll('#anatomyGrid input:checked');
    let score = 0;
    checks.forEach(c => score += parseInt(c.value));
    score = Math.min(100, score);
    state.complexity = score;
    document.getElementById('lblComplex').textContent = `Score: ${score}`;
    const baseB = 3.0 + (score / 100) * 8.0;
    document.getElementById('baseB').value = baseB.toFixed(1);
    
    if(skipSim !== true && document.getElementById('autoRun').checked) startSimulation();
  }

  function updateBleed(skipSim) {
    const score = parseInt(document.getElementById('scoreInput').value);
    document.getElementById('lblScore').textContent = score;
    const baseH = 0.5 + Math.pow(score/12, 1.8);
    document.getElementById('baseH').value = baseH.toFixed(1);
    
    if(skipSim !== true) startSimulation(); 
  }
  
  function updateAssumptions(skipSim) {
    document.getElementById('lblRho').textContent = document.getElementById('rhoInput').value;
    document.getElementById('lblBeta').textContent = document.getElementById('betaInput').value;
    
    if(skipSim !== true) startSimulation();
  }

  function initTrialList() {
    const list = document.getElementById('trialList');
    TRIALS.forEach(t => {
      const div = document.createElement('div');
      div.className = 'trial-item';
      const lbl = document.createElement('label');
      const box = document.createElement('input');
      box.type = 'checkbox';
      box.checked = true;
      box.addEventListener('change', () => toggleTrial(t.id));
      lbl.appendChild(box);
      lbl.appendChild(document.createTextNode(' ' + t.id));
      div.appendChild(lbl);
      list.appendChild(div);
    });
  }

  function toggleTrial(id) {
    if (state.excludedIds.includes(id)) {
      state.excludedIds = state.excludedIds.filter(x => x !== id);
    } else {
      state.excludedIds.push(id);
    }
    if(document.getElementById('autoRun').checked) startSimulation();
  }

  function startSimulation() {
    const baseB = parseFloat(document.getElementById('baseB').value);
    const baseH = parseFloat(document.getElementById('baseH').value);
    
    if(isNaN(baseB) || baseB < 0 || baseH < 0) {
        alert("Invalid input parameters.");
        return;
    }

    document.getElementById('runBtn').classList.add('processing');
    document.getElementById('runBtn').disabled = true;

    worker.postMessage({
      trials: TRIALS,
      baseB: baseB/100,
      baseH: baseH/100,
      nSims: 40000,
      complexityScore: state.complexity,
      strategy: state.strategy,
      indication: state.indication,
      excludedIds: state.excludedIds,
      rho: parseFloat(document.getElementById('rhoInput').value),
      betaInput: parseFloat(document.getElementById('betaInput').value)
    });
  }

  function exportResults() {
      if(!lastResults) { alert("Run simulation first."); return; }
      const data = {
          timestamp: new Date().toISOString(),
          version: "5.5",
          parameters: {
             strategy: state.strategy,
             indication: state.indication,
             complexity: state.complexity,
             bleedingRisk: document.getElementById('scoreInput').value,
             rho: document.getElementById('rhoInput').value,
             beta: document.getElementById('betaInput').value,
             excludedTrials: state.excludedIds
          },
          results: {
             ncb: document.getElementById('valNCB').textContent,
             ncb_CI_95: [lastResults.ncb_p025, lastResults.ncb_p975],
             probability: document.getElementById('valProb').textContent,
             nnt: document.getElementById('valNNT').textContent,
             heterogeneity: {
                 I2: lastResults.reB.I2,
                 tau2: lastResults.reB.tau2
             },
             egger: lastResults.egger
          },
          report: document.getElementById('reportContent').innerText
      };
      
      const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `cardiosynth_${Date.now()}.json`;
      a.click();
      URL.revokeObjectURL(url);
  }

  // --- REPORTING ---
  function generateMethodReport(d) {
     const rho = d.rho.toFixed(2);
     const beta = d.betaInput.toFixed(2);
     const ncb = (d.meanB + d.meanH) * 100;
     const prob = (d.positiveCount / 40000) * 100;
     const eggerTxt = d.egger ? `Egger's p${d.egger.pval}` : 'N/A';
     
     const txt = `
     REANALYSIS PROTOCOL:
     - Method: DerSimonian-Laird Random-Effects Meta-analysis with Monte Carlo Simulation (n=40,000).
     - Heterogeneity: Ischemia IÂ²=${d.reB.I2.toFixed(1)}%, tauÂ²=${d.reB.tau2.toFixed(3)}.
     - Bias Detection: ${eggerTxt}.
     - Assumptions: Correlation(Isch, Bleed) = ${rho}; Complexity Beta = ${beta}.
     - Time Models: Ischemia modeled as exponential saturation; Bleeding as linear accumulation (Assumption).
     
     RESULTS:
     - Net Clinical Benefit (NCB): ${ncb.toFixed(2)}% absolute risk difference.
     - NCB 95% CI: [${(d.ncb_p025*100).toFixed(2)}%, ${(d.ncb_p975*100).toFixed(2)}%].
     - Probability of Benefit: ${prob.toFixed(1)}%.
     - Tipping Point: Harm weight > ${d.tippingPoint ? d.tippingPoint.toFixed(1) : '>5.0'}x negates benefit.
     
     INTERPRETATION:
     The simulation indicates a ${prob > 80 ? 'HIGH' : prob < 20 ? 'LOW' : 'UNCERTAIN'} confidence in the ${state.strategy.toUpperCase()} strategy under the current statistical assumptions.
     `;
     document.getElementById('reportContent').innerText = txt;
     
     let head = "Clinical Equipoise";
     if(prob > 80) head = `${state.strategy === 'extended' ? 'Extended' : 'Short'} DAPT Favored`;
     else if(prob < 20) head = `${state.strategy === 'extended' ? 'Short' : 'Extended'} DAPT Favored`;
     document.getElementById('dynamicHeadline').innerText = head;
  }

  function updateMetrics(data) {
    const { meanB, meanH, positiveCount, tippingPoint } = data;
    const ncb = meanB + meanH; 
    
    document.getElementById('valNCB').textContent = (ncb * 100).toFixed(2) + "%";
    document.getElementById('cardNCB').className = ncb > 0 ? 'metric-card pos' : 'metric-card neg';
    
    const prob = (positiveCount / 40000) * 100;
    document.getElementById('valProb').textContent = prob.toFixed(1) + "%";
    
    const nnt = meanB > 0.0001 ? (1/meanB).toFixed(0) : "âˆž";
    const nnh = meanH < -0.0001 ? (1/Math.abs(meanH)).toFixed(0) : "âˆž";
    
    if (data.strategy === 'short') {
       document.getElementById('valNNT').textContent = meanH > 0 ? (1/meanH).toFixed(0) : "âˆž"; 
       document.getElementById('valNNH').textContent = meanB < 0 ? (1/Math.abs(meanB)).toFixed(0) : "âˆž"; 
    } else {
       document.getElementById('valNNT').textContent = nnt;
       document.getElementById('valNNH').textContent = nnh;
    }

    const tipTxt = tippingPoint ? `${tippingPoint.toFixed(1)}x` : "> 5.0x";
    document.getElementById('valTip').textContent = tipTxt;
  }

  // --- DRAWING ---
  function setupCanvas(id) {
    const c = document.getElementById(id);
    const rect = c.getBoundingClientRect();
    c.width = rect.width * 2; c.height = rect.height * 2;
    const ctx = c.getContext('2d');
    ctx.scale(2, 2);
    return { ctx, w: rect.width, h: rect.height };
  }

  function drawThreshold(thresholds, tippingPoint) {
    const { ctx, w, h } = setupCanvas('thresholdCanvas');
    const pad={l:40, r:20, t:20, b:30};
    const minX = 0.5, maxX = 5.0;
    const maxY = Math.max(...thresholds.map(d=>Math.abs(d.val))) * 1.5;
    const sx = v => pad.l + ((v-minX)/(maxX-minX))*(w-pad.l-pad.r);
    const sy = v => (h/2) - (v/maxY)*(h/2 - pad.t);

    ctx.strokeStyle='#222'; ctx.lineWidth=1;
    ctx.beginPath(); ctx.moveTo(pad.l, h/2); ctx.lineTo(w-pad.r, h/2); ctx.stroke();

    // Y Axis Labels
    ctx.fillStyle='#666'; ctx.textAlign='right'; ctx.font='10px Inter';
    for(let y = -0.10; y <= 0.10; y += 0.05) {
        if(y >= -maxY/20 && y <= maxY/20) continue; // skip zero clutter
        const py = sy(y);
        if(py > pad.t && py < h-pad.b) {
            ctx.fillText((y*100).toFixed(0)+'%', pad.l - 5, py + 3);
            ctx.beginPath(); ctx.moveTo(pad.l-3, py); ctx.lineTo(pad.l, py); ctx.stroke();
        }
    }

    ctx.beginPath(); ctx.lineWidth=3;
    thresholds.forEach((d, i) => {
        const x = sx(d.w); const y = sy(d.val);
        if(i===0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    });
    const grad = ctx.createLinearGradient(pad.l, 0, w-pad.r, 0);
    grad.addColorStop(0, thresholds[0].val > 0 ? '#10b981' : '#ef4444');
    grad.addColorStop(1, thresholds[thresholds.length-1].val > 0 ? '#10b981' : '#ef4444');
    ctx.strokeStyle = grad; ctx.stroke();

    if(tippingPoint) {
        const tx = sx(tippingPoint);
        ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(tx, h/2, 4, 0, 6.28); ctx.fill();
        ctx.fillStyle='#999'; ctx.font='10px Inter'; ctx.textAlign='center';
        ctx.fillText(`Tip: ${tippingPoint.toFixed(1)}x`, tx, h/2 - 12);
    }
    
    ctx.fillStyle='#666'; ctx.textAlign='center'; ctx.font='10px Inter';
    ctx.fillText("Harm Weight (Bleeding Penalty)", w/2, h-5);
    ctx.save(); ctx.translate(15, h/2); ctx.rotate(-1.57); 
    ctx.fillText("Net Benefit", 0,0); ctx.restore();
  }

  function drawScatter(data) {
    const { ctx, w, h } = setupCanvas('scatterCanvas');
    const cx=w/2; const cy=h/2;
    
    ctx.fillStyle='#111'; ctx.fillRect(cx, 0, cx, cy); 
    ctx.strokeStyle='#333'; ctx.lineWidth=1;
    ctx.beginPath(); ctx.moveTo(cx, 0); ctx.lineTo(cx, h); ctx.moveTo(0, cy); ctx.lineTo(w, cy); ctx.stroke();

    // X-axis labels (Safety/Bleeding)
    ctx.fillStyle='#666'; ctx.textAlign='center'; ctx.font='9px Inter';
    for(let x = -5; x <= 5; x += 2.5) {
        const px = cx + x * 20;
        if(px > 20 && px < w-20) {
            ctx.fillText(x.toFixed(1) + '%', px, h - 5);
        }
    }
    // Y-axis labels (Efficacy/Ischemia)
    ctx.textAlign='right';
    for(let y = -5; y <= 5; y += 2.5) {
        const py = cy - y * 20;
        if(py > 20 && py < h-20) {
            ctx.fillText(y.toFixed(1) + '%', 25, py + 3);
        }
    }

    data.plotPoints.forEach(p => {
      const x = cx + p.x * 20; 
      const y = cy - p.y * 20;
      ctx.fillStyle = (p.y + p.x > 0) ? 'rgba(16, 185, 129, 0.5)' : 'rgba(239, 68, 68, 0.5)';
      ctx.beginPath(); ctx.arc(x, y, 2, 0, 6.28); ctx.fill();
    });
    
    ctx.fillStyle='#fff'; ctx.font='10px Inter'; ctx.textAlign='right';
    ctx.fillText("Benefit (Ischemia)", w-10, cy-6);
    ctx.textAlign='left';
    ctx.fillText("Safety (Bleed)", cx+6, 12);
  }

  function drawTimeHorizon(timeData) {
    const { ctx, w, h } = setupCanvas('timeCanvas');
    const pad={l:30, r:20, t:20, b:30};
    
    ctx.strokeStyle='#333'; ctx.lineWidth=1;
    ctx.beginPath(); ctx.moveTo(pad.l, pad.t); ctx.lineTo(pad.l, h-pad.b); ctx.lineTo(w-pad.r, h-pad.b); ctx.stroke();
    
    const maxVal = 12; 
    const sx = m => pad.l + (m/36)*(w-pad.l-pad.r);
    const sy = v => (h-pad.b) - (v/maxVal)*(h-pad.t-pad.b);

    ctx.fillStyle='#10b981'; ctx.font='10px Inter'; ctx.fillText("Ischemia Averted", pad.l+10, pad.t+10);
    ctx.fillStyle='#ef4444'; ctx.fillText("Bleeds Caused", pad.l+10, pad.t+22);

    drawCurve(ctx, timeData, 'ti', '#10b981', 1.0, sx, sy);
    drawCurve(ctx, timeData, 'tb', '#ef4444', 1.0, sx, sy);
  }

  function drawCurve(ctx, data, key, color, alpha, sx, sy) {
    ctx.beginPath();
    ctx.strokeStyle = color; ctx.globalAlpha = alpha; ctx.lineWidth = 2;
    data.forEach((d, i) => {
      const x = sx(d.m); const y = sy(d[key]);
      if(i===0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    });
    ctx.stroke(); ctx.globalAlpha = 1.0;
  }

  function drawForest(meta, egger) {
    const { ctx, w, h } = setupCanvas('forestCanvas');
    const pad={l:90, r:20, t:30, b:20};
    const rowH = (h-50)/(meta.forest.length+2);
    const sx = v => pad.l + ((v+1.5)/3)*(w-pad.l-pad.r); 

    // Header Stats
    ctx.fillStyle='#888'; ctx.font='10px Inter'; ctx.textAlign='right';
    ctx.fillText(`IÂ²=${meta.I2.toFixed(0)}% Ï„Â²=${meta.tau2.toFixed(3)}`, w-pad.r, 20);

    // Egger's Badge
    if(egger) {
      ctx.textAlign = 'left';
      ctx.fillStyle = egger.pval === '<0.05' ? '#ef4444' : '#34d399';
      ctx.fillText(`Egger's p${egger.pval}`, pad.l, 20);
    }

    ctx.strokeStyle='#333'; ctx.lineWidth=1;
    ctx.beginPath(); ctx.moveTo(sx(0), pad.t); ctx.lineTo(sx(0), h-pad.b); ctx.stroke();

    meta.forest.forEach((f, i) => {
      const y = pad.t + i*rowH + rowH/2;
      ctx.fillStyle='#aaa'; ctx.textAlign='right'; ctx.font='10px Inter';
      ctx.fillText(f.id, pad.l-10, y+3);
      
      ctx.strokeStyle = f.val < 0 ? '#10b981' : '#ef4444';
      ctx.beginPath(); ctx.moveTo(sx(f.lo), y); ctx.lineTo(sx(f.hi), y); ctx.stroke();
      ctx.fillRect(sx(f.val)-2, y-2, 4, 4);
    });
    
    // Pooled Diamond
    const y = h-15;
    const cx = sx(meta.mu);
    const hw = (sx(meta.mu+1.96*meta.se_pool) - sx(meta.mu-1.96*meta.se_pool))/2;
    ctx.fillStyle='#fff';
    ctx.beginPath(); ctx.moveTo(cx-hw, y); ctx.lineTo(cx, y-4); ctx.lineTo(cx+hw, y); ctx.lineTo(cx, y+4); ctx.fill();
    
    // Prediction Interval (Thin Line)
    const px1 = sx(meta.pred_lo);
    const px2 = sx(meta.pred_hi);
    ctx.strokeStyle='#666'; ctx.setLineDash([2,2]);
    ctx.beginPath(); ctx.moveTo(px1, y); ctx.lineTo(px2, y); ctx.stroke();
    ctx.setLineDash([]);
  }

  function drawHist(bins) {
    const { ctx, w, h } = setupCanvas('histCanvas');
    const pad = 30;
    const maxH = Math.max(...bins.map(b=>b.y));
    const scaleX = i => pad + (i/bins.length)*(w-2*pad);
    const scaleY = v => (h-pad) - (v/maxH)*(h-2*pad);
    const barW = (w-2*pad)/bins.length;

    bins.forEach((b, i) => {
      ctx.fillStyle = b.x > 0 ? '#10b981' : '#ef4444';
      const bh = scaleY(b.y);
      ctx.fillRect(scaleX(i), bh, barW, (h-pad)-bh);
    });
    
    let zeroIdx = bins.findIndex(b => b.x > 0);
    if(zeroIdx === -1) zeroIdx = bins.length / 2;
    
    const zX = scaleX(zeroIdx);
    ctx.strokeStyle = '#fff'; ctx.beginPath(); ctx.moveTo(zX, pad); ctx.lineTo(zX, h-pad); ctx.stroke();
    
    ctx.fillStyle='#999'; ctx.textAlign='center';
    ctx.fillText("Net Benefit (%)", w/2, h-10);
  }
</script>
</body>
</html>
